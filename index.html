<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8" />
  
  <title>JavaYYLab</title>
  <meta name="author" content="John Doe" />

  

  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

  
  <meta property="og:site_name" content="JavaYYLab" />

  
  

  
    <meta property="og:image" content="" />
  

  
  <link href="/css/images/favicon.ico" rel="icon" />
  

  <link rel="alternate" href="/atom.xml" title="JavaYYLab" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  


  <!-- baidu webmaster push -->
  <script src='//push.zhanzhang.baidu.com/push.js'></script>

<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">JavaYYLab</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/archives">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2021-08-08T07:04:29.393Z"><a href="/2021/08/08/JC/">2021-08-08</a></time>
      
      
  
    <h1 class="title"><a href="/2021/08/08/JC/">JC</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="JC"><a href="#JC" class="headerlink" title="JC"></a>JC</h2><h3 id="如何判断一个对象是否存活"><a href="#如何判断一个对象是否存活" class="headerlink" title="如何判断一个对象是否存活"></a>如何判断一个对象是否存活</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">.引用计数法(难以解决对象之间循环引用)</span>	</span><br><span class="line"><span class="number">2</span><span class="string">.可达性分析法</span></span><br><span class="line">	<span class="attr">GC Root:</span> </span><br><span class="line">		<span class="string">a.Java虚拟机栈中(栈帧中的本地变量表)引用的对象</span></span><br><span class="line">		<span class="string">b.本地方法栈中引用的对象</span></span><br><span class="line">		<span class="string">c.方法区常量引用的对象</span></span><br><span class="line">		<span class="string">b.方法区类静态变量引用的对象</span>        </span><br></pre></td></tr></table></figure>

<h3 id="引用分类"><a href="#引用分类" class="headerlink" title="引用分类"></a>引用分类</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">.强引用:</span> <span class="string">当内存空间不足时,Java虚拟机宁愿抛出OutOfMemoryError错误,使程序异常终止,也不会靠随意回收具有强引用的对象来解决内存不足问题</span></span><br><span class="line"><span class="number">2</span><span class="string">.软引用:</span> <span class="string">当JVM认为内存不足时,才会去试图回收软引用指向的对象.JVM会确保在抛OutOfMemoryError之前,清理软引用指向的对象</span></span><br><span class="line"><span class="number">3</span><span class="string">.弱引用:</span> <span class="string">当</span> <span class="string">JVM</span> <span class="string">进行垃圾回收时，无论内存是否充足，都会回收只被弱引用关联的对象</span></span><br><span class="line"><span class="number">4</span><span class="string">.虚引用:</span> <span class="string">PhantomReference在堆对象被释放之前就被添加到它的ReferenceQueue,内存还没有释放。</span></span><br><span class="line"><span class="string">而软引用和弱引用在添加到对应的ReferenceQueue的时候，其指向真实内存的引用已经被置为空了，相关的内存也已经被释放掉了</span></span><br></pre></td></tr></table></figure>

<h3 id="回收方法区内存："><a href="#回收方法区内存：" class="headerlink" title="回收方法区内存："></a>回收方法区内存：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>回收废弃常量</span><br><span class="line">    只要常量池中的常量不被任何变量或对象引用，那么这些常量就会被清除掉。</span><br><span class="line"><span class="number">2.</span>无用的类(满足以下三个条件)</span><br><span class="line">	a.该类的所有对象都已经被清除</span><br><span class="line">	b.加载该类的ClassLoader已经被回收</span><br><span class="line">	c.该类的java.lang.Class对象没有在任何地方被引用,无法在任何地方通过反射访问该类的方法</span><br></pre></td></tr></table></figure>

<h3 id="垃圾收集算法："><a href="#垃圾收集算法：" class="headerlink" title="垃圾收集算法："></a>垃圾收集算法：</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">新生代:</span> <span class="string">复制算法</span></span><br><span class="line"><span class="string">老年代:</span> <span class="string">标记-清除算法、标记-整理算法</span></span><br></pre></td></tr></table></figure>

<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p>[<a target="_blank" rel="noopener" href="https://github.com/doocs/jvm/blob/main/docs/01-jvm-memory-structure.md]">https://github.com/doocs/jvm/blob/main/docs/01-jvm-memory-structure.md]</a>:</p>
<p>[<a target="_blank" rel="noopener" href="https://www.cnblogs.com/qq78292959/archive/2011/07/25/2116123.html]">https://www.cnblogs.com/qq78292959/archive/2011/07/25/2116123.html]</a>: </p>
<h3 id="PS"><a href="#PS" class="headerlink" title="PS:"></a>PS:</h3><p>白嫖来的，欢迎指正和交流，<a href="mailto:&#57;&#51;&#50;&#x36;&#x31;&#x37;&#x38;&#x33;&#x37;&#64;&#x71;&#x71;&#x2e;&#99;&#111;&#x6d;">&#57;&#51;&#50;&#x36;&#x31;&#x37;&#x38;&#x33;&#x37;&#64;&#x71;&#x71;&#x2e;&#99;&#111;&#x6d;</a></p>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
  
  <div class="categories">
    <a href="/categories/JVM/">JVM</a>
  </div>

        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2021-08-08T06:29:49.967Z"><a href="/2021/08/08/JVM内存结构/">2021-08-08</a></time>
      
      
  
    <h1 class="title"><a href="/2021/08/08/JVM内存结构/">JVM内存结构</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h2><h3 id="JVM进程在操作系统中的内存结构："><a href="#JVM进程在操作系统中的内存结构：" class="headerlink" title="JVM进程在操作系统中的内存结构："></a>JVM进程在操作系统中的内存结构：</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">JVM虚拟机数据区(JVM分配管理的内存)：</span></span><br><span class="line">    <span class="string">线程独享:</span> <span class="string">程序计数器，java虚拟机栈，本地方法栈</span></span><br><span class="line">    <span class="string">线程共享:</span> <span class="string">堆--新生代(eden,from</span> <span class="string">survior,to</span> <span class="string">survior),老年代</span></span><br><span class="line"><span class="string">本地内存(操心系统分配管理的内存):</span></span><br><span class="line">	<span class="string">线程共享：</span></span><br><span class="line">        <span class="string">元数据区-方法区(取代JDK1.7的永久代):加载类信息,常量,静态变量,即时编译器编译后代码</span></span><br><span class="line">        <span class="string">直接内存</span>    </span><br></pre></td></tr></table></figure>

<h3 id="JVM虚拟机栈内容："><a href="#JVM虚拟机栈内容：" class="headerlink" title="JVM虚拟机栈内容："></a>JVM虚拟机栈内容：</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">1:</span> <span class="string">局部变量表(八大原始类型,对象引用,返回地址)</span></span><br><span class="line"><span class="attr">2:</span> <span class="string">操作数栈</span></span><br><span class="line"><span class="attr">3:</span> <span class="string">动态链接</span></span><br><span class="line"><span class="attr">4:</span> <span class="string">方法出口信息</span></span><br><span class="line"><span class="attr">5:</span> <span class="string">...</span></span><br></pre></td></tr></table></figure>

<h3 id="直接内存vs堆内存："><a href="#直接内存vs堆内存：" class="headerlink" title="直接内存vs堆内存："></a>直接内存vs堆内存：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>直接内存申请空间耗费更高的性能</span><br><span class="line"><span class="number">2.</span>直接内存读取 IO 的性能要优于普通的堆内存</span><br><span class="line"><span class="number">3.</span>直接内存作用链： 本地 IO -&gt; 直接内存 -&gt; 本地 IO</span><br><span class="line"><span class="number">4.</span>堆内存作用链：本地 IO -&gt; 直接内存 -&gt; 非直接内存 -&gt; 直接内存 -&gt; 本地 IO</span><br></pre></td></tr></table></figure>

<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p>[<a target="_blank" rel="noopener" href="https://github.com/doocs/jvm/blob/main/docs/01-jvm-memory-structure.md]">https://github.com/doocs/jvm/blob/main/docs/01-jvm-memory-structure.md]</a>: </p>
<h3 id="PS"><a href="#PS" class="headerlink" title="PS:"></a>PS:</h3><p>白嫖来的，欢迎指正和交流，<a href="mailto:&#57;&#x33;&#50;&#x36;&#x31;&#55;&#x38;&#x33;&#55;&#x40;&#113;&#x71;&#x2e;&#x63;&#x6f;&#x6d;">&#57;&#x33;&#50;&#x36;&#x31;&#55;&#x38;&#x33;&#55;&#x40;&#113;&#x71;&#x2e;&#x63;&#x6f;&#x6d;</a></p>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
  
  <div class="categories">
    <a href="/categories/JVM/">JVM</a>
  </div>

        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2021-08-08T03:40:47.877Z"><a href="/2021/08/08/Kafka/">2021-08-08</a></time>
      
      
  
    <h1 class="title"><a href="/2021/08/08/Kafka/">Kafka</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><h3 id="如何保证不丢数据（可靠性）："><a href="#如何保证不丢数据（可靠性）：" class="headerlink" title="如何保证不丢数据（可靠性）："></a>如何保证不丢数据（可靠性）：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>生产端:</span><br><span class="line">设置 acks=all ：这个是要求每条数据，必须是写入所有 replica 之后，才能认为是写成功了</span><br><span class="line">设置 retries=MAX （无限次重试的意思）：这个是要求一旦写入失败，就无限重试，卡在这里了。</span><br><span class="line"><span class="number">2.</span>服务端：</span><br><span class="line">给 topic 设置 replication.factor 值必须大于 <span class="number">1</span>，要求每个 partition 必须有至少 <span class="number">2</span> 个副本。</span><br><span class="line">设置 min.insync.replicas 值必须大于 <span class="number">1</span>，这个是要求一个 leader 至少感知到有至少一个 follower 还跟自己保持联系，没掉队，这样才能确保 leader 挂了还有一个 同步的follower可以选举为leader</span><br><span class="line"><span class="number">3.</span>消费端：</span><br><span class="line">手动提交offset，即处理完了再提交</span><br></pre></td></tr></table></figure>



<h3 id="消息队列如何选型（神图）："><a href="#消息队列如何选型（神图）：" class="headerlink" title="消息队列如何选型（神图）："></a>消息队列如何选型（神图）：</h3><table>
<thead>
<tr>
<th>特性</th>
<th>ActiveMQ</th>
<th>RabbitMQ</th>
<th>RocketMQ</th>
<th>Kafka</th>
</tr>
</thead>
<tbody><tr>
<td>单机吞吐量</td>
<td>万级，比 RocketMQ、Kafka 低一个数量级</td>
<td>同 ActiveMQ</td>
<td>10 万级，支撑高吞吐</td>
<td>10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景</td>
</tr>
<tr>
<td>topic 数量对吞吐量的影响</td>
<td></td>
<td></td>
<td>topic 可以达到几百/几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic</td>
<td>topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源</td>
</tr>
<tr>
<td>时效性</td>
<td>ms 级</td>
<td>微秒级，这是 RabbitMQ 的一大特点，延迟最低</td>
<td>ms 级</td>
<td>延迟在 ms 级以内</td>
</tr>
<tr>
<td>可用性</td>
<td>高，基于主从架构实现高可用</td>
<td>同 ActiveMQ</td>
<td>非常高，分布式架构</td>
<td>非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td>
</tr>
<tr>
<td>消息可靠性</td>
<td>有较低的概率丢失数据</td>
<td>基本不丢</td>
<td>经过参数优化配置，可以做到 0 丢失</td>
<td>同 RocketMQ</td>
</tr>
<tr>
<td>功能支持</td>
<td>MQ 领域的功能极其完备</td>
<td>基于 erlang 开发，并发能力很强，性能极好，延时很低，适用于做订阅通知</td>
<td>MQ 功能较为完善，还是分布式的，扩展性好</td>
<td>功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用</td>
</tr>
</tbody></table>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p>[<a target="_blank" rel="noopener" href="https://github.com/doocs/advanced-java/blob/main/docs/high-concurrency/how-to-ensure-high-availability-of-message-queues.md]">https://github.com/doocs/advanced-java/blob/main/docs/high-concurrency/how-to-ensure-high-availability-of-message-queues.md]</a>: </p>
<h3 id="PS"><a href="#PS" class="headerlink" title="PS:"></a>PS:</h3><p>个人见解，欢迎指正和交流，<a href="mailto:&#x39;&#51;&#50;&#x36;&#x31;&#55;&#56;&#51;&#55;&#64;&#x71;&#113;&#46;&#x63;&#x6f;&#109;">&#x39;&#51;&#50;&#x36;&#x31;&#55;&#56;&#51;&#55;&#64;&#x71;&#113;&#46;&#x63;&#x6f;&#109;</a></p>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
  
  <div class="categories">
    <a href="/categories/消息队列/">消息队列</a>
  </div>

        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2021-08-08T02:49:17.252Z"><a href="/2021/08/08/RabbitMQ/">2021-08-08</a></time>
      
      
  
    <h1 class="title"><a href="/2021/08/08/RabbitMQ/">RabbitMQ</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><h3 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式:"></a>集群模式:</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">镜像集群模式:</span> <span class="string">高可用，但是数据复制度高，复制度=数据节点数量*100%，所以不适用保存大量数据，用来订阅通知比较合适（可以参考Kakfa是怎么降低这个复制度的）</span></span><br><span class="line"><span class="string">普通集群模式:</span> <span class="string">无高可用，只有一台机器保留队列元数据和实际数据，其他机器只保留队列元数据，提高吞吐量</span></span><br><span class="line"><span class="string">单机模式:</span> <span class="string">本地demo用</span></span><br></pre></td></tr></table></figure>

<h3 id="如何保证不丢数据（可靠性）："><a href="#如何保证不丢数据（可靠性）：" class="headerlink" title="如何保证不丢数据（可靠性）："></a>如何保证不丢数据（可靠性）：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>生产端:</span><br><span class="line">推荐方案：开启confirm模式（异步）</span><br><span class="line">其他方案：开启事务（同步）</span><br><span class="line"><span class="number">2.</span>服务端：</span><br><span class="line">开启持久化，包括队列，消息等持久化</span><br><span class="line"><span class="number">3.</span>消费端：</span><br><span class="line">关闭自动ACK,进行手动ACK</span><br></pre></td></tr></table></figure>



<h3 id="消息队列如何选型（神图）："><a href="#消息队列如何选型（神图）：" class="headerlink" title="消息队列如何选型（神图）："></a>消息队列如何选型（神图）：</h3><table>
<thead>
<tr>
<th>特性</th>
<th>ActiveMQ</th>
<th>RabbitMQ</th>
<th>RocketMQ</th>
<th>Kafka</th>
</tr>
</thead>
<tbody><tr>
<td>单机吞吐量</td>
<td>万级，比 RocketMQ、Kafka 低一个数量级</td>
<td>同 ActiveMQ</td>
<td>10 万级，支撑高吞吐</td>
<td>10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景</td>
</tr>
<tr>
<td>topic 数量对吞吐量的影响</td>
<td></td>
<td></td>
<td>topic 可以达到几百/几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic</td>
<td>topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源</td>
</tr>
<tr>
<td>时效性</td>
<td>ms 级</td>
<td>微秒级，这是 RabbitMQ 的一大特点，延迟最低</td>
<td>ms 级</td>
<td>延迟在 ms 级以内</td>
</tr>
<tr>
<td>可用性</td>
<td>高，基于主从架构实现高可用</td>
<td>同 ActiveMQ</td>
<td>非常高，分布式架构</td>
<td>非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td>
</tr>
<tr>
<td>消息可靠性</td>
<td>有较低的概率丢失数据</td>
<td>基本不丢</td>
<td>经过参数优化配置，可以做到 0 丢失</td>
<td>同 RocketMQ</td>
</tr>
<tr>
<td>功能支持</td>
<td>MQ 领域的功能极其完备</td>
<td>基于 erlang 开发，并发能力很强，性能极好，延时很低，适用于做订阅通知</td>
<td>MQ 功能较为完善，还是分布式的，扩展性好</td>
<td>功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用</td>
</tr>
</tbody></table>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p>[<a target="_blank" rel="noopener" href="https://github.com/doocs/advanced-java/blob/main/docs/high-concurrency/how-to-ensure-high-availability-of-message-queues.md]">https://github.com/doocs/advanced-java/blob/main/docs/high-concurrency/how-to-ensure-high-availability-of-message-queues.md]</a>: </p>
<h3 id="PS"><a href="#PS" class="headerlink" title="PS:"></a>PS:</h3><p>个人见解，欢迎指正和交流，<a href="mailto:&#x39;&#x33;&#x32;&#54;&#49;&#x37;&#x38;&#x33;&#55;&#x40;&#113;&#113;&#46;&#99;&#111;&#109;">&#x39;&#x33;&#x32;&#54;&#49;&#x37;&#x38;&#x33;&#55;&#x40;&#113;&#113;&#46;&#99;&#111;&#109;</a></p>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
  
  <div class="categories">
    <a href="/categories/消息队列/">消息队列</a>
  </div>

        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2021-08-08T02:35:33.110Z"><a href="/2021/08/08/消息队列/">2021-08-08</a></time>
      
      
  
    <h1 class="title"><a href="/2021/08/08/消息队列/">消息队列</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><h3 id="消息队列的用处"><a href="#消息队列的用处" class="headerlink" title="消息队列的用处:"></a>消息队列的用处:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">解耦、异步、削峰</span><br></pre></td></tr></table></figure>



<h3 id="消息队列如何选型（神图）："><a href="#消息队列如何选型（神图）：" class="headerlink" title="消息队列如何选型（神图）："></a>消息队列如何选型（神图）：</h3><table>
<thead>
<tr>
<th>特性</th>
<th>ActiveMQ</th>
<th>RabbitMQ</th>
<th>RocketMQ</th>
<th>Kafka</th>
</tr>
</thead>
<tbody><tr>
<td>单机吞吐量</td>
<td>万级，比 RocketMQ、Kafka 低一个数量级</td>
<td>同 ActiveMQ</td>
<td>10 万级，支撑高吞吐</td>
<td>10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景</td>
</tr>
<tr>
<td>topic 数量对吞吐量的影响</td>
<td></td>
<td></td>
<td>topic 可以达到几百/几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic</td>
<td>topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源</td>
</tr>
<tr>
<td>时效性</td>
<td>ms 级</td>
<td>微秒级，这是 RabbitMQ 的一大特点，延迟最低</td>
<td>ms 级</td>
<td>延迟在 ms 级以内</td>
</tr>
<tr>
<td>可用性</td>
<td>高，基于主从架构实现高可用</td>
<td>同 ActiveMQ</td>
<td>非常高，分布式架构</td>
<td>非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td>
</tr>
<tr>
<td>消息可靠性</td>
<td>有较低的概率丢失数据</td>
<td>基本不丢</td>
<td>经过参数优化配置，可以做到 0 丢失</td>
<td>同 RocketMQ</td>
</tr>
<tr>
<td>功能支持</td>
<td>MQ 领域的功能极其完备</td>
<td>基于 erlang 开发，并发能力很强，性能极好，延时很低，适用于做订阅通知</td>
<td>MQ 功能较为完善，还是分布式的，扩展性好</td>
<td>功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用</td>
</tr>
</tbody></table>
<h3 id="消息队列如何保证不重复消费："><a href="#消息队列如何保证不重复消费：" class="headerlink" title="消息队列如何保证不重复消费："></a>消息队列如何保证不重复消费：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>如果处理逻辑是入库的，则解决一下主键和唯一键冲突即可</span><br><span class="line"><span class="number">2.</span>如果是通知订阅的，事件处理的，且接收到通知只能处理一次，这种可以增加一个事件ID(分布式全局唯一)，然后处理完之后存redis，重复消费时候查缓存已经有了就不处理了</span><br></pre></td></tr></table></figure>

<h3 id="如何保证消息的顺序性："><a href="#如何保证消息的顺序性：" class="headerlink" title="如何保证消息的顺序性："></a>如何保证消息的顺序性：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">设置路由字段</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/doocs/advanced-java/raw/main/docs/high-concurrency/images/kafka-order-02.png" alt="kafka-order-02"></p>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p>[<a target="_blank" rel="noopener" href="https://github.com/doocs/advanced-java/edit/main/docs/high-concurrency/why-mq.md]">https://github.com/doocs/advanced-java/edit/main/docs/high-concurrency/why-mq.md]</a>: </p>
<h3 id="PS"><a href="#PS" class="headerlink" title="PS:"></a>PS:</h3><p>个人见解，欢迎指正和交流，<a href="mailto:&#x39;&#51;&#x32;&#x36;&#49;&#55;&#56;&#51;&#x37;&#x40;&#113;&#x71;&#46;&#99;&#x6f;&#x6d;">&#x39;&#51;&#x32;&#x36;&#49;&#55;&#56;&#51;&#x37;&#x40;&#113;&#x71;&#46;&#99;&#x6f;&#x6d;</a></p>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
  
  <div class="categories">
    <a href="/categories/消息队列/">消息队列</a>
  </div>

        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2021-08-07T10:34:45.537Z"><a href="/2021/08/07/堆排序/">2021-08-07</a></time>
      
      
  
    <h1 class="title"><a href="/2021/08/07/堆排序/">堆排序</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="堆排序–查找数组中第K大的元素"><a href="#堆排序–查找数组中第K大的元素" class="headerlink" title="堆排序–查找数组中第K大的元素"></a>堆排序–查找数组中第K大的元素</h2><h3 id="题："><a href="#题：" class="headerlink" title="题："></a>题：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。</span><br><span class="line">请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</span><br><span class="line">输入: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>] 和 k = <span class="number">2</span></span><br><span class="line">输出: <span class="number">5</span></span><br></pre></td></tr></table></figure>

<h3 id="思"><a href="#思" class="headerlink" title="思:"></a>思:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最大堆: 每个子树根节点是最大的</span><br></pre></td></tr></table></figure>

<h3 id="解-java"><a href="#解-java" class="headerlink" title="解(java)"></a>解(java)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> pos1, <span class="keyword">int</span> pos2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = arr[pos1];</span><br><span class="line">    arr[pos1] = arr[pos2];</span><br><span class="line">    arr[pos2] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    buildMaxHeap(nums);</span><br><span class="line">    <span class="keyword">int</span> size=nums.length;</span><br><span class="line">    <span class="keyword">if</span>(size==<span class="number">0</span>||size&lt;k)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;++i)&#123;</span><br><span class="line">        res=nums[<span class="number">0</span>];</span><br><span class="line">        swap(nums,size-<span class="number">1</span>-i,<span class="number">0</span>);</span><br><span class="line">        adjustDown(nums,<span class="number">0</span>,size-<span class="number">1</span>-i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adjustDown</span><span class="params">(<span class="keyword">int</span>[] vr,<span class="keyword">int</span> k,<span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp=vr[k];</span><br><span class="line">    <span class="keyword">int</span> size=len;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>*k+<span class="number">1</span>;i&lt;size;i=i*<span class="number">2</span>+<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i+<span class="number">1</span>&lt;size&amp;&amp;vr[i+<span class="number">1</span>]&gt;vr[i])</span><br><span class="line">            i=i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(tmp&gt;=vr[i])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        vr[k]=vr[i];</span><br><span class="line">        k=i;</span><br><span class="line">    &#125;</span><br><span class="line">    vr[k]=tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildMaxHeap</span><span class="params">(<span class="keyword">int</span>[] vr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=vr.length/<span class="number">2</span>-<span class="number">1</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">        adjustDown(vr,i,vr.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] vr)</span></span>&#123;</span><br><span class="line">    buildMaxHeap(vr);</span><br><span class="line">    <span class="keyword">int</span> size=vr.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size;++i)&#123;</span><br><span class="line">        swap(vr,<span class="number">0</span>,size-<span class="number">1</span>-i);</span><br><span class="line">        adjustDown(vr,<span class="number">0</span>,size-<span class="number">1</span>-i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>验证：</p>
<p>[<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/description/]">https://leetcode-cn.com/problems/kth-largest-element-in-an-array/description/]</a>: </p>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
  
  <div class="categories">
    <a href="/categories/算法/">算法</a>
  </div>

        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2021-08-07T08:08:18.179Z"><a href="/2021/08/07/快排/">2021-08-07</a></time>
      
      
  
    <h1 class="title"><a href="/2021/08/07/快排/">快排</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="快排-查找数组中最小K个数"><a href="#快排-查找数组中最小K个数" class="headerlink" title="快排-查找数组中最小K个数"></a>快排-查找数组中最小K个数</h2><h3 id="题："><a href="#题：" class="headerlink" title="题："></a>题：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入整数数组 arr ，找出其中最小的 k 个数。例如，输入<span class="number">4</span>、<span class="number">5</span>、<span class="number">1</span>、<span class="number">6</span>、<span class="number">2</span>、<span class="number">7</span>、<span class="number">3</span>、<span class="number">8</span>这<span class="number">8</span>个数字，则最小的<span class="number">4</span>个数字是<span class="number">1</span>、<span class="number">2</span>、<span class="number">3</span>、<span class="number">4</span>。</span><br><span class="line">输入：arr = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>], k = <span class="number">2</span></span><br><span class="line">输出：[<span class="number">1</span>,<span class="number">2</span>] 或者 [<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h3 id="思："><a href="#思：" class="headerlink" title="思："></a>思：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>先挖走一个元素作为比较对象，留下一个坑，从右边找出小的，替换比较对象，生成新坑，再从左边找出大的替换，再换到右边，最后左边后右边碰上后结束，再把比较对象放回坑内（最边都比比较对象小，右边都比比较对象大，数组相对有序）</span><br><span class="line"><span class="number">2.</span>递归比较对象左边和右边的数组</span><br><span class="line"><span class="number">3.</span>递归截止判断条件为数组只有一个元素时候，一个元素肯定有序了</span><br></pre></td></tr></table></figure>

<h3 id="解-java"><a href="#解-java" class="headerlink" title="解(java)"></a>解(java)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span>[] getLeastNumbers(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k) &#123;</span><br><span class="line">       <span class="keyword">int</span>[] res=<span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">if</span>(k==<span class="number">0</span>)&#123;</span><br><span class="line">           res=<span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">           <span class="keyword">return</span> res;</span><br><span class="line">       &#125;        </span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">null</span>==arr||arr.length==<span class="number">0</span>||k&gt;=arr.length)&#123;</span><br><span class="line">           <span class="keyword">return</span> arr;</span><br><span class="line">       &#125;</span><br><span class="line">       res=<span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">       <span class="keyword">int</span> beg=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> end=arr.length-<span class="number">1</span>;</span><br><span class="line">       <span class="keyword">int</span> restfindCount=k;</span><br><span class="line">       <span class="keyword">int</span> mid=<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">           mid=partition(arr,beg,end);</span><br><span class="line">           <span class="keyword">if</span>(mid==k-<span class="number">1</span>)&#123;</span><br><span class="line">               System.arraycopy(arr,<span class="number">0</span>,res,<span class="number">0</span>,k);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(mid&gt;k-<span class="number">1</span>)&#123;</span><br><span class="line">               end=mid-<span class="number">1</span>;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               beg=mid+<span class="number">1</span>;</span><br><span class="line">               restfindCount=restfindCount-(mid+<span class="number">1</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> pos1, <span class="keyword">int</span> pos2)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> tmp = arr[pos1];</span><br><span class="line">       arr[pos1] = arr[pos2];</span><br><span class="line">       arr[pos2] = tmp;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> beg,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (beg == end) &#123;</span><br><span class="line">           <span class="keyword">return</span> beg;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> left=beg;</span><br><span class="line">       <span class="keyword">int</span> right=end;</span><br><span class="line">       <span class="keyword">int</span> cur=arr[beg];</span><br><span class="line">       <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">           <span class="keyword">while</span>(left&lt;right&amp;&amp;arr[right]&gt;=cur)right--;</span><br><span class="line">           swap(arr,left,right);</span><br><span class="line">           <span class="keyword">while</span>(left&lt;right&amp;&amp;arr[left]&lt;=cur)left++;</span><br><span class="line">           swap(arr,right,left);</span><br><span class="line">       &#125;</span><br><span class="line">       arr[left]=cur;</span><br><span class="line">       <span class="keyword">return</span> left;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快排</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> beg,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(end&gt;beg)&#123;</span><br><span class="line">           <span class="keyword">int</span> mid=partition(arr,beg,end);</span><br><span class="line">           quickSort(arr,beg,mid);</span><br><span class="line">           quickSort(arr,mid+<span class="number">1</span>,end);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>验证：</p>
<p>[<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/]">https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/]</a>: </p>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
  
  <div class="categories">
    <a href="/categories/算法/">算法</a>
  </div>

        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2021-08-01T14:14:07.735Z"><a href="/2021/08/01/归并排序/">2021-08-01</a></time>
      
      
  
    <h1 class="title"><a href="/2021/08/01/归并排序/">归并排序</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="归并排序–统计数组中的逆序对"><a href="#归并排序–统计数组中的逆序对" class="headerlink" title="归并排序–统计数组中的逆序对"></a>归并排序–统计数组中的逆序对</h2><h3 id="题："><a href="#题：" class="headerlink" title="题："></a>题：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</span><br><span class="line">输入: [<span class="number">7</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">输出: <span class="number">5</span></span><br></pre></td></tr></table></figure>

<h3 id="思"><a href="#思" class="headerlink" title="思:"></a>思:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>定位数组索引中间值，递归排序左边和右边</span><br><span class="line"><span class="number">2.</span>合并最边已经排序好的数组和右边已经排序好数组</span><br><span class="line"><span class="number">3.</span>递归截止判断条件为数组只有一个元素时候，一个元素肯定有序了</span><br></pre></td></tr></table></figure>

<h3 id="解-java"><a href="#解-java" class="headerlink" title="解(java)"></a>解(java)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">0</span>||nums.length==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] arrayTmp= <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        sort(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>,arrayTmp);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> beg,<span class="keyword">int</span> end,<span class="keyword">int</span>[] arrayTmp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(beg&gt;=end)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid=beg+(end-beg)/<span class="number">2</span>;<span class="comment">//尽量避免溢出</span></span><br><span class="line">        sort(nums,beg,mid,arrayTmp);</span><br><span class="line">        sort(nums,mid+<span class="number">1</span>,end,arrayTmp);</span><br><span class="line">        System.arraycopy(nums,beg,arrayTmp,beg,end-beg+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> begA=beg;</span><br><span class="line">        <span class="keyword">int</span> begB=mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> start=beg;</span><br><span class="line">        <span class="keyword">while</span>(begA&lt;=mid&amp;&amp;begB&lt;=end)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arrayTmp[begA]&gt;arrayTmp[begB])&#123;</span><br><span class="line">                res+=(mid-begA+<span class="number">1</span>);<span class="comment">//本题关键点，统计以(?,arrayTmp[begB])形式的逆序对</span></span><br><span class="line">                nums[start++]=arrayTmp[begB++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums[start++]=arrayTmp[begA++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(begA&lt;=mid)&#123;</span><br><span class="line">            System.arraycopy(arrayTmp,begA,nums,start,mid-begA+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(begB&lt;=end)&#123;</span><br><span class="line">            System.arraycopy(arrayTmp,begB,nums,start,end-begB+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>验证：</p>
<p>[<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/]">https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/]</a>: </p>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
  
  <div class="categories">
    <a href="/categories/算法/">算法</a>
  </div>

        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2021-08-01T12:31:32.073Z"><a href="/2021/08/01/二叉树的前中后遍历特点/">2021-08-01</a></time>
      
      
  
    <h1 class="title"><a href="/2021/08/01/二叉树的前中后遍历特点/">二叉树前中后序遍历特点</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="二叉树前中后序遍历特点"><a href="#二叉树前中后序遍历特点" class="headerlink" title="二叉树前中后序遍历特点"></a>二叉树前中后序遍历特点</h2><h3 id="题："><a href="#题：" class="headerlink" title="题："></a>题：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。</span><br><span class="line">假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</span><br><span class="line">Input: preorder = [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="number">15</span>,<span class="number">7</span>], inorder = [<span class="number">9</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">7</span>]</span><br><span class="line">Output: [<span class="number">3</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="number">15</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure>

<h3 id="思"><a href="#思" class="headerlink" title="思"></a>思</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">前序遍历特点(根-&gt;左-&gt;右):</span> <span class="string">遍历后根节点第一个</span></span><br><span class="line"><span class="string">中序遍历特点(左-&gt;根-&gt;右):</span> <span class="string">遍历后，根节点左边为左子树，右边为右子树</span></span><br><span class="line"><span class="string">后序遍历特点(左-&gt;右-&gt;根):</span> <span class="string">遍历后根节点为最后一个</span></span><br></pre></td></tr></table></figure>

<p>解(java)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(preorder.length==<span class="number">0</span>||inorder.length==<span class="number">0</span>)</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">if</span>(preorder.length==<span class="number">1</span>)</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line">          <span class="keyword">if</span>(inorder.length==<span class="number">1</span>)</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(inorder[<span class="number">0</span>]);</span><br><span class="line">          TreeNode root=construct(preorder,<span class="number">0</span>,preorder.length-<span class="number">1</span>,inorder,<span class="number">0</span>,inorder.length-<span class="number">1</span>);</span><br><span class="line">          <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">construct</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> beg,<span class="keyword">int</span> end,<span class="keyword">int</span> [] in,<span class="keyword">int</span> beg2,<span class="keyword">int</span> end2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(beg&gt;=pre.length||end&lt;<span class="number">0</span>||beg2&gt;=in.length||end2&lt;<span class="number">0</span>||beg&gt;end||beg2&gt;end2)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root=<span class="keyword">new</span> TreeNode(pre[beg]);</span><br><span class="line">        <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=beg2;i&lt;=end2;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(in[i]==root.val)&#123;</span><br><span class="line">                index=i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        root.left=construct(pre,beg+<span class="number">1</span>,beg+<span class="number">1</span>+index-<span class="number">1</span>-beg2+<span class="number">1</span>-<span class="number">1</span>,in,beg2,index-<span class="number">1</span>);</span><br><span class="line">        root.right=construct(pre,beg+<span class="number">1</span>+index-<span class="number">1</span>-beg2+<span class="number">1</span>-<span class="number">1</span>+<span class="number">1</span>,end,in,index+<span class="number">1</span>,end2);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>验证：</p>
<p>[<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/submissions/]">https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/submissions/]</a>: </p>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
  
  <div class="categories">
    <a href="/categories/算法/">算法</a>
  </div>

        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2021-08-01T09:18:36.837Z"><a href="/2021/08/01/二叉树的后序遍历/">2021-08-01</a></time>
      
      
  
    <h1 class="title"><a href="/2021/08/01/二叉树的后序遍历/">二叉树后序遍历</a></h1>
  

    </header>
    <div class="entry">
      
        <h2 id="二叉树后序遍历"><a href="#二叉树后序遍历" class="headerlink" title="二叉树后序遍历"></a>二叉树后序遍历</h2><h3 id="题："><a href="#题：" class="headerlink" title="题："></a>题：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">给定一个二叉树，返回它的 后序 遍历。</span><br><span class="line">输入: [<span class="number">1</span>,<span class="keyword">null</span>,<span class="number">2</span>,<span class="number">3</span>]  </span><br><span class="line">   <span class="number">1</span></span><br><span class="line">    \</span><br><span class="line">     <span class="number">2</span></span><br><span class="line">    /</span><br><span class="line">   <span class="number">3</span> </span><br><span class="line">输出: [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h3 id="解-c"><a href="#解-c" class="headerlink" title="解(c++)"></a>解(c++)</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span>(root)&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; sk;</span><br><span class="line">        TreeNode *cut=<span class="literal">NULL</span>;</span><br><span class="line">        TreeNode *cur=root;<span class="comment">//从下到上的拦截节点，即刚刚添加值后的节点，防止回退</span></span><br><span class="line">        <span class="keyword">while</span>(cur||sk.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur)&#123;</span><br><span class="line">                sk.<span class="built_in">push</span>(cur);</span><br><span class="line">                cur=cur-&gt;left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur=sk.<span class="built_in">top</span>();</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right&amp;&amp;cur-&gt;right!=cut)</span><br><span class="line">                    cur=cur-&gt;right;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">                    sk.<span class="built_in">pop</span>();</span><br><span class="line">                    cut=cur;</span><br><span class="line">                    cur=<span class="literal">NULL</span>;</span><br><span class="line">                &#125;                        </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解(java)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;List&lt;Integer&gt;&gt; threadLocal=<span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span>==root)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        threadLocal.set(res);</span><br><span class="line">        getLeftThenRightAndCur(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getLeftThenRightAndCur</span><span class="params">(TreeNode cur)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        getLeftThenRightAndCur(cur.left);</span><br><span class="line">        getLeftThenRightAndCur(cur.right);</span><br><span class="line">        threadLocal.get().add(cur.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>验证：</p>
<p>[<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/submissions/]">https://leetcode-cn.com/problems/binary-tree-postorder-traversal/submissions/]</a>: </p>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
  
  <div class="categories">
    <a href="/categories/算法/">算法</a>
  </div>

        
        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>






<nav id="pagination">
  
  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页 &amp;raquo;</a>
  </nav>

</nav>
</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:example.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">分类</h3>
  <ul class="entry">
  
    <li><a href="/categories/JVM/">JVM</a><small>2</small></li>
  
    <li><a href="/categories/常用指令/">常用指令</a><small>1</small></li>
  
    <li><a href="/categories/消息队列/">消息队列</a><small>3</small></li>
  
    <li><a href="/categories/算法/">算法</a><small>7</small></li>
  
    <li><a href="/categories/计算机术语/">计算机术语</a><small>1</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">最新文章</h3>
  <ul class="entry">
    
      <li>
        <a href="/2021/08/08/JC/">JC</a>
      </li>
    
      <li>
        <a href="/2021/08/08/JVM内存结构/">JVM内存结构</a>
      </li>
    
      <li>
        <a href="/2021/08/08/Kafka/">Kafka</a>
      </li>
    
      <li>
        <a href="/2021/08/08/RabbitMQ/">RabbitMQ</a>
      </li>
    
      <li>
        <a href="/2021/08/08/消息队列/">消息队列</a>
      </li>
    
  </ul>
</div>


  

  
</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  <p>
  
  &copy; 2021 John Doe
  
  All rights reserved.</p>
  <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
</div>
<div class="clearfix"></div>

<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script></footer>
  <script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


<div id='bg'></div>
</body>
</html>